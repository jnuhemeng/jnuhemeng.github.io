I"h2<h3 id="hyperloglog简介">HyperLogLog简介</h3>
<p><a href="https://redis.io/topics/data-types-intro">Redis HyperLogLog</a>(以下简称HLL)实现了一种叫做“HyperLogLog”的算法，并以Redis数据结构的形式提供给开发者使用。HLL只做一件事情，即统计集合中不重复元素的个数（术语叫做集合基数）。<br />
集合基数的统计用Redis中的set数据结构和Java中的Set集合类都可以实现，但是由于它们都会实际存储集合元素——存储空间正比于集合基数，因此它们不适合集合基数比较大的场景。HLL使用“精度换空间”的权衡策略，实现了以12kB的常量存储空间开销，得到标准误（standard error）为0.81%的集合基数估计值，并且集合基数的上限可以达到2^64。HLL不存储集合元素，只存储一个反映已添加集合元素的状态，因此能够实现常量空间复杂度。<br />
Redis HLL在实现上没有引入新的数据结构，而是复用了string数据结构，即HLL底层是用string编码的。</p>

<h4 id="使用场景举例">使用场景举例</h4>
<p>服务每天被多少个不重复的IP访问过？<br />
接口每月被多少个不重复的用户ID访问过？<br />
搜索每天接收到了多少个不重复的搜索词请求？</p>

<h3 id="hyperloglog命令">HyperLogLog命令</h3>
<p>HLL的API非常简单，包括3条命令：</p>

<table>
  <thead>
    <tr>
      <th>command</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>PFADD</td>
      <td>往HLL“添加”元素</td>
    </tr>
    <tr>
      <td>PFCOUNT</td>
      <td>读取HLL当前集合基数</td>
    </tr>
    <tr>
      <td>PFMERGE</td>
      <td>合并两个或多个HLL</td>
    </tr>
  </tbody>
</table>

<h4 id="pfadd-往hll添加元素"><a href="https://redis.io/commands/pfadd">PFADD</a>: 往HLL“添加”元素</h4>
<p>PFADD key [element [element …]]</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis&gt;  PFADD hll a b c d e f g
<span class="o">(</span>integer<span class="o">)</span> 1
redis&gt;  PFCOUNT hll
<span class="o">(</span>integer<span class="o">)</span> 7
</code></pre></div></div>
<p><strong>返回值</strong><br />
Integer reply, specifically:<br />
　　1 if at least 1 HyperLogLog internal register was altered. 0 otherwise.<br />
<strong>时间复杂度</strong><br />
　　O(1)时间复杂度<br />
PFADD命令执行时，如果key还不存在就会先创建一个空的HLL；然后把key后面的元素（如有）“添加”到HLL。HLL实际上不会存储PFADD命令“添加”进来的元素，而是对元素进行计算看是否需要更新内部寄存器状态（如果需要则更新寄存器并返回1，否则返回0）。所以，无法从HLL取出之前通过PFADD命令“添加”进去的元素。</p>

<h4 id="pfcount-读取hll当前集合基数"><a href="https://redis.io/commands/pfcount">PFCOUNT</a>: 读取HLL当前集合基数</h4>
<p>PFCOUNT key [key …]</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis&gt;  PFADD hll foo bar zap
<span class="o">(</span>integer<span class="o">)</span> 1
redis&gt;  PFADD hll zap zap zap
<span class="o">(</span>integer<span class="o">)</span> 0
redis&gt;  PFADD hll foo bar
<span class="o">(</span>integer<span class="o">)</span> 0
redis&gt;  PFCOUNT hll
<span class="o">(</span>integer<span class="o">)</span> 3
redis&gt;  PFADD some-other-hll 1 2 3
<span class="o">(</span>integer<span class="o">)</span> 1
redis&gt;  PFCOUNT hll some-other-hll
<span class="o">(</span>integer<span class="o">)</span> 6
</code></pre></div></div>
<p><strong>返回值</strong><br />
Integer reply, specifically:<br />
　　The approximated number of unique elements observed via PFADD.<br />
<strong>时间复杂度</strong><br />
　　只传一个key时O(1)时间复杂度（内部可缓存，快），传N个key时O(N)时间复杂度（无法缓存，毫秒级级）。<br />
当只传1个key时，如果集合基数的缓存值有效就直接返回缓存的集合基数，否则计算集合基数并返回；当传多个key时，Redis内部先把这些key对应HLL合并成得到1个临时HLL，然后计算并返回这个HLL的集合基数。</p>

<h4 id="pfmerge-合并两个或多个hll"><a href="https://redis.io/commands/pfmerge">PFMERGE</a>: 合并两个或多个HLL</h4>
<p>PFMERGE destkey sourcekey [sourcekey …]</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis&gt;  PFADD hll1 foo bar zap a
<span class="o">(</span>integer<span class="o">)</span> 1
redis&gt;  PFADD hll2 a b c foo
<span class="o">(</span>integer<span class="o">)</span> 1
redis&gt;  PFMERGE hll3 hll1 hll2
<span class="s2">"OK"</span>
redis&gt;  PFCOUNT hll3
<span class="o">(</span>integer<span class="o">)</span> 6
</code></pre></div></div>
<p><strong>返回值</strong><br />
Simple string reply: The command just returns OK.<br />
<strong>时间复杂度</strong><br />
　　合并N个HLL时O(N)时间复杂度<br />
把1个destkey和多个sourcekey合并成1个HLL并写到destkey中，命令执行完成时destkey的集合基数等于这些集合的并集的集合基数值。</p>

<p>HLL内部用Redis string编码，因此支持GET和SET命令。在对HLL执行这2个命令时，Redis会进行相应的序列化和反序列化操作。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis&gt; PFADD hll a b c d e f g
<span class="o">(</span>integer<span class="o">)</span> 1
redis&gt; get hll
<span class="s2">"HYLL</span><span class="se">\x</span><span class="s2">01</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">00</span><span class="se">\x</span><span class="s2">80Fm</span><span class="se">\x</span><span class="s2">80V</span><span class="se">\x</span><span class="s2">0c</span><span class="se">\x</span><span class="s2">80@</span><span class="se">\x</span><span class="s2">e9</span><span class="se">\x</span><span class="s2">80CQ</span><span class="se">\x</span><span class="s2">848</span><span class="se">\x</span><span class="s2">80P</span><span class="se">\x</span><span class="s2">b1</span><span class="se">\x</span><span class="s2">84I</span><span class="se">\x</span><span class="s2">8c</span><span class="se">\x</span><span class="s2">80Bm</span><span class="se">\x</span><span class="s2">80BZ"</span>
redis&gt; 
</code></pre></div></div>

<h3 id="hyperloglog原理">HyperLogLog原理</h3>
<p>Redis HLL的全部理论来源是如下2篇文献：<br />
P. Flajolet, Éric Fusy, O. Gandouet, and F. Meunier. <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">Hyperloglog: The  analysis of a near-optimal cardinality estimation algorithm</a>.<br />
Heule, Nunkesser, Hall: <a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=30F1D3FD363452B76390182D2F5E58F0?doi=10.1.1.308.9527&amp;rep=rep1&amp;type=pdf">HyperLogLog in Practice: Algorithmic  Engineering of a State of The Art Cardinality Estimation Algorithm</a>.<br />
文献中严谨的推理过程比较晦涩难懂，这里简单介绍一下HLL最基本的思路。</p>

<h4 id="抛硬币"><a href="http://antirez.com/news/75">抛硬币</a></h4>
<p>甲在抛一枚硬币，抛到反面就继续抛，抛到正面就停止从而完成一个回合，记下这个回合抛到的连续反面的次数。甲在进行多个回合后，把他在这些回合中抛到的连续反面次数的最大值告诉乙，让乙猜一下甲一共进行了多少个回合。<br />
如果甲抛到的连续反面次数的最大值是3，那么很可能甲只进行了很少几个回合；如果甲抛到的连续反面次数的最大值是13，那么很可能甲进行了很多个回合。因此，乙实际上可以根据甲提供的连续次数的最大值给出回合数的猜测值。<br />
显然乙依据这种猜测方法给出的猜测值可能会存在很大的误差，比如，甲运气比较好，在第一个回合就抛出了连续10次反面，并马上告诉乙，这时候乙会给出一个误差很大的猜测值。假如让甲同时抛10枚硬币，并用10张纸分别记录各个硬币的连续反面次数最大值，最后把这10张纸交给乙，这种情况下乙的猜测值就会准确很多。<br />
HLL算法的基本思路跟这个抛硬币例子基本相同。</p>

<h4 id="hll算法基本思路"><a href="https://en.wikipedia.org/wiki/HyperLogLog">HLL算法基本思路</a></h4>
<p><strong>HLL算法基础</strong>：</p>
<ul>
  <li>HLL算法基于这样的观察，对于一个由均匀分布的随机数构成的集合，可以先把这些随机数转化成二进制表示，然后计算每个二进制表示的前导0个数，找出这些二进制表示中前导0个数的最大值n，通过n可以估计这个集合的集合基数，近似等于2^n。</li>
  <li>HLL通过哈希函数把原始集合转化成由均匀分布的随机数构成的集合，从而可以使用上面的方法对原始集合的集合基数进行估算。</li>
  <li>HLL为了减小误差，把原始集合分割成多子集合，先对各个子集合应用上述算法，最后把所有子集合的结果通过调和平均数组合成对原始集合的集合基数估计值。</li>
</ul>

<p><strong>Add： “添加”元素操作</strong><br />
往HLL“添加”元素V的操作如下图所示：
<img src="/assets/image/20210718hll_add.svg" alt="HLL Add Operation" />
step 1: 用哈希函数h把元素v转换成由特定bit数表示的值x；<br />
step 2: 将x的前b个bit构成的数加1得到j，用j定位到寄存器M[j]；<br />
step 3: 计算x从b+1开始往后的所有bit构成的二进制串w的前导0个数ρ(w);<br />
step 4: 比较ρ(w)和M[j]的大小,把大值赋给M[j]。</p>

<p><strong>Count: 计算集合基数操作</strong><br />
计算HLL集合基数时,先计算m个寄存器集合基数的调和平均值,然后乘上一个修正系数得到整个HLL的基数集合。如下图所示:
<img src="/assets/image/20210718hll_count1_1.svg" alt="HLL Count Operation" />
<img src="/assets/image/20210718hll_count1_2.svg" alt="HLL Count Operation" />
<img src="/assets/image/20210718hll_count1_3.svg" alt="HLL Count Operation" />
寄存器j计算得到的集合基数值为2^M[j],根据第一个公式可以得到m个寄存器的集合基数的调和平均值为mZ;假设HLL的集合基数为n,那么每个寄存器的平均集合基数为n/m,所以n=m^Z;另外,由于哈希碰撞,需要再用一个系数 α m来修正。最终得到的HLL集合基数值如上述第三个公式所示。
考虑到系数 α m中的积分在实际实现时处理起来不太方便,通常用如下公式来近似(m为寄存器个数):<br />
<img src="/assets/image/20210718hll_count2_1.svg" alt="HLL Count Operation" />
当集合基数小于5/2m时,HLL原始算法得到的集合基数的误差会比较大,这时会切换到另一种叫做Linear Counting的算法以进一步减小误差。<br />
通过上述修正,HLL算法得到的集合基数的标准误为:<br />
<img src="/assets/image/20210718hll_count2_2.svg" alt="HLL Count Operation" /></p>

<p><strong>Merge: 合并集合操作</strong><br />
合并2个HLL集合的操作,就是把下标相同的寄存器分别合并的过程:<br />
<img src="/assets/image/20210718hll_merge.svg" alt="HLL Count Operation" /></p>

<h4 id="redis-hll实现"><a href="https://github.com/redis/redis/blob/unstable/src/hyperloglog.c">Redis HLL实现</a></h4>
<p>Redis HLL工作步骤:<br />
(1) 用哈希函数把”添加”到HLL的元素转化成64bits的二进制表示;<br />
(2) 低14bits用来定位寄存器,所以一共需要2^14个寄存器;<br />
(3) 高50bits用来计算第一个”1”出现的位置,可见取值范围为[1,51],所以寄存器只要6bits大小即可(2^6=64 &gt; 51);<br />
(4) 如果(3)得到的值比(2)定位到的寄存器的当前值大,就用它更新(2)定位到的寄存器的值,否则不更新。<br />
<a href="http://content.research.neustar.biz/blog/hll.html">动画演示</a></p>

<p>集合基数计算: 把寄存器个数m=2^14以及各个寄存器的当前值M[j]代入到上面的公式,就可以得到当前集合基数的估计值E,同时可以计算得到标准误1.04/sqrt(m)=0.81%。<br />
内存开销</p>

<hr />

<p>参考：<br />
《Linux Shell脚本攻略》</p>

:ET