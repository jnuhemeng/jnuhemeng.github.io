---
layout: post
title: 辗转相除法
tags:
  - 算法与数据结构
---

辗转相除法（即欧几里德算法）是一种求最大公约数的算法。两个不全为0的非负整数的最大公约数记为gcd(m, n)（这里假定m不小于n），并且g(m, 0)=m。该算法的步骤为：  
第一步：如果n=0,返回m的值作为结果，同时过程结束；否则，进入第二步；
第二步：m除以n，将余数赋给r；
第三步：将n的值赋给m，将r的值赋给n，返回第一步。

C语言实现代码如下：
```C
#include <stdio.h>

int gcd(int m, int n)
{
	while(n != 0) {
		int r = m % n;
		m = n;
		n = r;
	}

	return m;
}

int main()
{
	int m, n;
	while(scanf("%d %d", &m, &n) != EOF)
		printf("gcd(%d, %d)=%d\n", m, n, gcd(m, n));

	return 0;
}
```

由于每经过一次循环，n的值都会变小并且绝不会变成负数。因此n最终会变成0，从而使算法能够在有限的循环次数内结束。

为什么辗转相除法是正确的？换句话说，如何证明gcd(m, n) = gcd(n, m mod n)？
证明：  
如果a能被b整除，则记“a | b”。又记：(p为整数)  
m = pn + (m mod n)   (1)
(m mod n) = m - pn   (2)  
令gcd(m, n) = g1, gcd(n, m mod n) = g2。则有  
m | g1, n | g1, n | g2, (m mod n) | g2。
所以， (1)式等号右边的每一项都能够被g2整除，因此(1)式等号左边的部分也能被g2整除，即  
m | g2。再结合n | g2可知，g2是n和m的公约数，故g2 <= g1。  
同理可由(2)式得知g1是n和(m mod n)的公约数，故g1 <= g2。  
所以，g1 = g2，即gcd(m, n) = gcd(n, m mod n)。








### 2.35
>
A. 假定一个k位指数和n位小数的浮点格式，给出不能准确描述的最小正整数的公式（因为要想准确表示它需要n+1为小数）。

不能准确描述的最小正整数的公式如下式所示：
	![2.35答案](/assets/image/20180325csapp0235A.gif)
在IEEE浮点标准中，正整数只能由规格化值表示，因为非规格化值只能表示小于或等于0的数（假设k>=2），而特殊数值则只能表示正无穷、负无穷和NaN。  
不能准确描述的最小正整数比能准确描述的最大正整数大1，因此只要求出能准确描述的最大正整数即可。对于k为指数和n位小数的浮点格式，能准确描述的最大整数对应的位模式为：符号位为0，指数域除了最低位为0外全部为1，小数域全部为1。即
	![2.35答案](/assets/image/20180325csapp0235A2.gif)
而不能准确描述的最小正整数等于上式加1。

---

>
B. 对于单精度格式（k=8, n=23），这个整数的数字值是多少？

将k=8, n=23代入A的式子中，即可得到该整数的值。如下式所示：
	![2.35答案](/assets/image/20180325csapp0235B.gif)








