---
layout: post
title: 雪花算法
tags:
  - 分布式系统
---

### [雪花算法（Snowflake）](https://en.wikipedia.org/wiki/Snowflake_ID)
雪花算法是一种用于生成分布式唯一标志的算法，最早是由Twitter在2010年提出的，所生成的唯一标志称为雪花ID（Snowflake ID）。雪花ID由64 bits组成，如下图所示：
![Snowflake](/assets/image/20210826snowflake.png)
**1 bit**：目前没有用到，取值永远为0；  
**41 bits**： 时间戳，毫秒粒度，从某个选定的时刻（epoch）起到当前时刻为止所流失的时间，最大可以表示69年；  
**10 bits**： 机器编号，最多2^10=1024台机器；  
**12 bits**： 机器内序列号，每个毫秒内单个机器可以产生2^12=4096个ID；  

雪花ID由于是基于时间戳创建的，所以不仅可以基于时间排序，而且可以从它的值计算出其创建时间（如用这个特性来找某个特定时刻之前或之后创建的雪花ID及其关联的对象）。  
在实际使用时，通常会对雪花算法做一定的调整，比如，如果服务不需要运行69年但是机器又不止1024台，那么就可以调整为用39bits来表示时间戳、12bits来表示机器编号并且仍然用12bits表示机器内序列号。  


### 一种基于zookeeper的雪花算法实现方案
**1bit符号位**： 取值永远为0；  
**39 bits 时间戳**： epoch选为2018-01-01 00:00:00，时钟发生回退就回收机器编号并分配一个新的机器编号，回收的机器编号记录在zk的“/snowflake/{namespace}/recycle”路径下且后续不再使用；  
**4 bits IDC编号**： 不同机房配置不同的值；  
**10 bits 机器编号**： 从0开始编号、最大可达2^10-1，每个机器的机器编号存放在zk的“/snowflake/{namespace}/{机器IP}/{机器端口}”（端口可选）路径下；  
**10 bits 机器内序列号**。  

**实现细节**：1）分配新的机器编号前先用zk的分布式锁InterProcessMutex来锁定“/snowflake/{namespace}/lock”路径，分配时把zk的“/snowflake/{namespace}/recycle”路径和所有“/snowflake/{namespace}/{机器IP}/{机器端口}”路径下的机器编号拉取下来用于去重，从0~(2^10-1)之间随机选一个不曾被占用的值作为新分配的机器编号，分配完成后释放zk的分布式锁InterProcessMutex。  
2）如果同一个时间戳下某个机器的机器内序列号已经用完，就通过自旋锁来等待下一个时间戳的到来。同样地，如果时钟发生回退并且回退的时间间隔不是很长，也通过自选锁来等待时间戳重新回到正常时刻；  
3）为了避免机器内部并发时出现竞争问题，雪花算法暴露出去的用于获取雪花ID的接口用synchronous关键字加锁保护。  
